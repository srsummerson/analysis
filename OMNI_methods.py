import numpy as np
import scipy as sp
from scipy import signal
import re
from neo import io
import pandas as pd
from matplotlib import pyplot as plt
import matplotlib as mpl
from matplotlib import mlab


def convert_OMNI(filename, **kwargs):
	'''
	This method converts csv files saved using the OMNI device to a pandas DataFrame for easy
	analysis in Python.

	Input:
		- filename: string containing the file path for a csv file saved with the OMNI device
	Optional inputs:
		- save_pkl: True/False to save pkl file, default is False
		- new_file_path: location to save new pkl file
		- animal_id: string containing subject's name, e.g. Mario, for naming of saved pkl file
		
	Output:
		- data: pandas DataFrame, M rows x N columns, M = number of data points, N = number of channels + 1, 
				first N -1 columns corresponds to data from the differnt channels while the Nth column 
				contains the timestamps 

	'''
	kwargsdict = {}
	kwargsdict['save_pkl'] = False
	expected_args = ['save_pkl', 'new_file_path','animal_id']
	for key in kwargs.keys():
		if key in expected_args:
			kwargsdict[key] = kwargs[key]
		else:
			raise Exception("Unexpected Argument")

	f = open(filename,'r')

	header = [line.strip() for i,line in enumerate(f) if (line.strip() != '')&(i < 2)]
	year = header[1][:4]  	# assumes date has format YYYY-MM-DD
	month = header[1][5:7] 	# assumes date has format YYYY-MM-DD
	day = header[1][8:10] 	# assumes date has format YYYY-MM-DD

	data = pd.read_csv(filename,sep=',',header=None,skiprows=[0,1])
	data = np.array(data)

	if kwargsdict['save_pkl']:
		pkl_filename = kwargsdict['animal_id'] + year + month + day + '_OMNIdata.pkl'
		new_filename = kwargsdict['new_file_path']+pkl_filename
		data.to_pickle(new_filename)

	f.close()

	return data


def plotRawLFPTraces(data, **kwargs):
	'''
	This method plots the raw LFP data for all channels or a subset of channels in a single plot 
	for easy viewing. Data is normalized to have zero DC component. Spacing between traces is determined by 
	the max standard deviation across all channels.

	Input:
		- data: numpy array, as generated by the convert_OMNI method
	Optional input:
		- channs: list of channels to be plotted
		- filter_data: True/False if low-pass filter is applied to data, default is False
	'''
	num_channs = data.shape[1]
	 		
	if kwargs:
		channs = kwargs['channs']
	else:
		channs = range(1,num_channs,1) 	# recall one column is for timestamps, not channel data

	channs = [(chann - 1) for chann in channs]  # channel numbers are offset by 1 from index values

	'''
	if filter_data:
		cutoff_f = 100
		cutoff_f = cutoff_f/(1000./2)  # sampling rate is 1000 Hz
		num_taps = 100
		lpf = signal.firwin(num_taps,cutoff_f,window='hamming')
		for chann in channs:
			data[:][chann] = signal.lfilter(lpf,1,data[:][chann])
	'''

	mean_vec = np.mean(data[:,channs], axis = 0)
	std_vec = np.std(data[:,channs], axis = 0)

	for i, chann in enumerate(channs):
		test_above_thres = np.ravel(np.nonzero(np.greater(data[:,chann],mean_vec[i] + 8*std_vec[i])))
		test_below_thres = np.ravel(np.nonzero(np.less(data[:,chann],mean_vec[i] - 4*std_vec[i])))
		ind_to_be_corrected = np.append(test_above_thres, test_below_thres)
		ind_to_be_corrected = [ind for ind in ind_to_be_corrected]
		for ind in ind_to_be_corrected:
			if ind + 1 < data.shape[0]:
				data[ind,chann] = (data[ind-1, chann] + data[ind+1,chann])/2.
			else:
				data[ind,chann] = data[ind-1, chann]

	mean_vec = np.mean(data[:,channs], axis = 0)
	std_vec = np.std(data[:,channs], axis = 0)
	trace_dist = 0.25*np.max([std_vec])  # don't include std of time stamps when 

	times = data[:,num_channs-1]

	plt.figure()
	cmap = mpl.cm.brg
	for i, chann in enumerate(channs):
		plt.plot(times[:5000],data[:5000,chann] - mean_vec[i] + i*trace_dist,color=cmap(i/float(len(channs))), label=str(chann))
	plt.xlabel('Time (s)')
	plt.title('LFP Traces')
	plt.legend()

	plt.show()

	return 